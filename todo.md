## Optimize: reduce instance values object that hold only one value

```js
// Instead of...
_xvdomJSX(_xvdomSpec, {a: msg});

// ... allocate NOTHING ooooh yeah motha fucka
_xvdomJSX(_xvdomSpec, msg);
```

## API: Instance creation xvdom.jsx

Currently, the following JSX...


```js
var msg = "hello";
<div>{msg}</div>
```

... would produce this code for the instance:

```js
({
  s: _xvdomSpec,
  v: {
    a: msg
  }
  c: null,
  n: null
})
```

Unfortunately this creates 2 objects, where previously on created 1 object.
We could get around this without resorting to Megamorphic IC call sites, if
we did the following...

```js
_xvdomJSX(_xvdomSpec, {a: msg});
```

... with the assumption that `xvdom.jsx()` efficiently handles recycling of
instance objects.

```js
function Instance(spec, values){
  this.s = spec;
  this.v = values;
}

Instance.prototype.c = null;
Instance.prototype.n = null;
Instance.prototype.x = null;

/*
HEAD -->  {A}
           |
           v
          {B}
           |
           v
          {C}
           |
           v
          null
*/
let instHead = null;
function jsx(spec, values){
  if(insteadHead === null) return new Instance(spec, values);

  let r = instHead;
  instHead = r.x;
  r.s = spec;
  r.v = values;
  return r;
}

function pushInstance(inst){
  inst.x = instHead;
  instHead = inst;
}

function rerenderInstance(inst, prevInst){
  pushInstance(inst);
}
```

## Optimize: make recycling completely generated

Recycling is only beneficial in a very limited set of use cases.
It gained prominence in a few VDOM implementations as a way to
game the vdom benchmarks.

Although it doesn't add alot of weight to the library, it could
be completely generated by the compiler.  This has the benefit
of allowing user's pay the tax **only if it's used**.

### API requirements

We need a hook for unmounting.  So we know when to recycle.

### Explicit `recycleKey` attribute

## Unit/Integration specs for pathing algorithm

## Code Generation: Cloneable temporary variable recycling

Consider the output for cloneable-save-path-nodes:

```js
(inst.i = _n2 = _n.lastChild).id = inst.j;
(inst.e = _n4 = (_n3 = _n2.previousSibling.firstChild).nextSibling).id = inst.f;
(inst.g = _n4.nextSibling.firstChild).id = inst.h;
(inst.a = (_n5 = _n3.firstChild).firstChild.firstChild).id = inst.b;
(inst.c = _n5.lastChild.firstChild).id = inst.d;
```

`_n2`, `_n4`, `_n3` could be reused for another node after it's been used, since it is not referenced again after it's used.
An optimized output could reuse a variable once it's contents is no longer needed...

```js
(inst.i = _n2 = _n.lastChild).id = inst.j;
(inst.e = _n3 = (_n2 = _n2.previousSibling.firstChild).nextSibling).id = inst.f;
(inst.g = _n3.nextSibling.firstChild).id = inst.h;
(inst.a = (_n2 = _n2.firstChild).firstChild.firstChild).id = inst.b;
(inst.c = _n2.lastChild.firstChild).id = inst.d;
```

... the number of temp variables was reduced to 2 (`_n2` and `_n3`).
